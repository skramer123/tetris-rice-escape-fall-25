<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Tetris Fill with Music + Alien Escape</title>
<style>
    body {
        background: #111;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        color: white;
        font-family: Arial, sans-serif;
    }
    #gameContainer { position: relative; }
    #board {
        background: #222;
        image-rendering: pixelated;
        border: 4px solid #555;
        display: block;
    }
    #message {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0,0,0,0.7);
        padding: 20px 40px;
        border-radius: 10px;
        font-size: 32px;
        text-align: center;
        display: none;
        pointer-events: none;
    }
    #nextBox {
        position: absolute;
        top: 10px;
        right: -140px;
        width: 120px;
        height: 130px;
        border: 2px solid #666;
        background: #111;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        color: #bbb;
        font-size: 11px;
        padding: 4px;
        box-shadow: 0 0 10px rgba(0,0,0,0.6);
    }
    #blocksRemaining {
        margin-top: 4px;
        font-size: 11px;
        color: #bbb;
        text-align: center;
    }
    /* Timer on the left side */
    #timerBox {
        position: absolute;
        top: 10px;
        left: -140px;
        width: 120px;
        height: 40px;
        border: 2px solid #666;
        background: #111;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #bbb;
        font-size: 16px;
        box-shadow: 0 0 10px rgba(0,0,0,0.6);
    }
    audio { display:none; }

    /* Reset progress bar (R) */
    #resetBarWrapper {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 70%;
        max-width: 260px;
        display: none;
        text-align: center;
        font-size: 14px;
    }
    #resetBarBG {
        width: 100%;
        height: 10px;
        background: rgba(255,255,255,0.2);
        border-radius: 5px;
        overflow: hidden;
        margin-bottom: 4px;
    }
    #resetBarFill {
        height: 100%;
        width: 0%;
        background: #4caf50;
        transition: width 0.1s linear;
    }

    /* Raise-target progress bar (H during game) */
    #raiseBarWrapper {
        position: absolute;
        bottom: 40px;
        left: 50%;
        transform: translateX(-50%);
        width: 70%;
        max-width: 260px;
        display: none;
        text-align: center;
        font-size: 14px;
    }
    #raiseBarBG {
        width: 100%;
        height: 10px;
        background: rgba(255,255,255,0.2);
        border-radius: 5px;
        overflow: hidden;
        margin-bottom: 4px;
    }
    #raiseBarFill {
        height: 100%;
        width: 0%;
        background: #ff9800;
        transition: width 0.1s linear;
    }

    /* Full-screen alien overlay when timer hits 0 */
    #alienOverlay {
        position: fixed;
        inset: 0;
        background: url('alien.png') no-repeat center center;
        background-size: cover;
        display: none;
        pointer-events: none;
        z-index: 10;
    }

    /* Full-screen escape overlay when holding W */
    #escapeOverlay {
        position: fixed;
        inset: 0;
        background: #000;
        display: none;
        z-index: 20;
        pointer-events: none;
    }
    #escapeText {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 64px;
        text-align: center;
        width: 100%;
    }
</style>
</head>
<body>

<div id="gameContainer">
    <canvas id="board"></canvas>
    <div id="message"></div>

    <!-- Timer on left -->
    <div id="timerBox">
        <span id="timerDisplay">01:00</span>
    </div>

    <div id="nextBox">
        <div id="nextLabel">Next</div>
        <canvas id="nextCanvas" width="80" height="60"></canvas>
        <div id="blocksRemaining">Blocks remaining: 23</div>
    </div>

    <!-- Reset bar (R anytime) -->
    <div id="resetBarWrapper">
        <div id="resetBarBG">
            <div id="resetBarFill"></div>
        </div>
        <div id="resetBarText">Hold R to reset</div>
    </div>

    <!-- Raise-target bar (H during game) -->
    <div id="raiseBarWrapper">
        <div id="raiseBarBG">
            <div id="raiseBarFill"></div>
        </div>
        <div id="raiseBarText">Hold H to raise target</div>
    </div>
</div>

<!-- Overlays -->
<div id="alienOverlay"></div>
<div id="escapeOverlay">
    <div id="escapeText">Congratulations! You Escaped!</div>
</div>

<!-- Background music: only restarts on FULL reset, not on Try Again -->
<audio id="bgm" src="mix-chunk-1_uLO4kfAU.mp3" loop></audio>

<!-- Win sounds: both play simultaneously on win -->
<audio id="winSound1" src="electric-motor-whir-77588.mp3"></audio>
<audio id="winSound2" src="win.mp3"></audio>

<script>
const COLS = 10, ROWS = 20, BLOCK = 30;
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");
const msgEl = document.getElementById("message");
const nextCanvas = document.getElementById("nextCanvas");
const nctx = nextCanvas.getContext("2d");
const bgm = document.getElementById("bgm");
const winSound1 = document.getElementById("winSound1");
const winSound2 = document.getElementById("winSound2");

const resetBarWrapper = document.getElementById("resetBarWrapper");
const resetBarFill = document.getElementById("resetBarFill");
const resetBarText = document.getElementById("resetBarText");

const raiseBarWrapper = document.getElementById("raiseBarWrapper");
const raiseBarFill = document.getElementById("raiseBarFill");

const blocksRemainingEl = document.getElementById("blocksRemaining");
const timerDisplay = document.getElementById("timerDisplay");
const alienOverlay = document.getElementById("alienOverlay");
const escapeOverlay = document.getElementById("escapeOverlay");

canvas.width = COLS * BLOCK;
canvas.height = ROWS * BLOCK;

let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
let pieceIndex = 0, currentPiece = null;
let gameOver = false, lastResultWasWin = false;
let gameStarted = false;

// smooth falling
let lastTime = 0, fallTimer = 0, softDrop = false;
const fallInterval = 650;

// R key hold for reset (now allowed anytime)
let rHeld = false;
let rHoldStart = null;

// H key hold for raising target zone
let hHeld = false;
let hHoldStart = null;
let targetRaised = false; // true when H has been held long enough this run

// Timer: 1 minute countdown
const TIMER_START_MS = 1 * 60 * 1000;
let timerRemaining = TIMER_START_MS;
let aliensActive = false;

// W key hold for escape
let wHeld = false;
let wHoldStart = null;
let escapeActive = false;

// COLORS
const COLORS = ["#000","#f44","#4f4","#44f","#ff4","#f4f","#4ff","#f80","#cc0"];

// PIECES
const PIECES = [
    {shape:[[1,1,1],[0,1,0]],color:1},
    {shape:[[2,2,0],[0,2,2]],color:2},
    {shape:[[0,3,3],[3,3,0]],color:3},
    {shape:[[4,4],[4,4]],color:4},
    {shape:[[8,8],[8,8]],color:8},
    {shape:[[6,6,6],[6,0,0]],color:6},
    {shape:[[7,7,7],[0,0,7]],color:7}
];

// hard-coded piece order (23 pieces)
let pieceOrder = [
    0,3,1,4,2,6,5,0,2,4,6,1,
    3,5,0,2,4,6,1,3,5,0,
    2
];

function updateBlocksRemaining(){
    if(!blocksRemainingEl) return;
    const total = pieceOrder.length;
    const used = pieceIndex;
    const current = currentPiece ? 1 : 0;
    const remaining = Math.max(0, total - used + current);
    blocksRemainingEl.textContent = "Blocks remaining: " + remaining;
}

function formatTime(ms){
    const totalSec = Math.max(0, Math.floor(ms / 1000));
    const m = Math.floor(totalSec / 60);
    const s = totalSec % 60;
    return (m < 10 ? "0"+m : m) + ":" + (s < 10 ? "0"+s : s);
}

function updateTimerDisplay(){
    timerDisplay.textContent = formatTime(timerRemaining);
}

function drawBlock(x,y,colorIndex){
    if(colorIndex===0) return;
    ctx.fillStyle = COLORS[colorIndex];
    ctx.fillRect(x*BLOCK, y*BLOCK, BLOCK-1, BLOCK-1);
}

function drawBoard(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    for(let r=0;r<ROWS;r++)
        for(let c=0;c<COLS;c++)
            drawBlock(c,r,board[r][c]);

    if(currentPiece){
        for(let r=0;r<currentPiece.shape.length;r++)
            for(let c=0;c<currentPiece.shape[r].length;c++)
                if(currentPiece.shape[r][c])
                    drawBlock(currentPiece.x+c, currentPiece.y+r, currentPiece.color);
    }

    // highlight target region
    // normal: bottom 10 rows; raised: top boundary moves up by 1, bottom row still included
    const startRow = targetRaised ? ROWS - 11 : ROWS - 10;
    const rowsHighlighted = ROWS - startRow; // 10 normally, 11 when raised
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.fillRect(0, startRow*BLOCK, COLS*BLOCK, rowsHighlighted*BLOCK);

    ctx.strokeStyle = "rgba(255,255,255,0.4)";
    ctx.lineWidth = 2;
    ctx.strokeRect(1, startRow*BLOCK+1, COLS*BLOCK-2, rowsHighlighted*BLOCK-2);
}

function collision(px,py,shape){
    for(let r=0;r<shape.length;r++){
        for(let c=0;c<shape[r].length;c++){
            if(shape[r][c]){
                let nx=px+c, ny=py+r;
                if(nx<0||nx>=COLS||ny>=ROWS) return true;
                if(ny>=0 && board[ny][nx]) return true;
            }
        }
    }
    return false;
}

function placePiece(){
    for(let r=0;r<currentPiece.shape.length;r++)
        for(let c=0;c<currentPiece.shape[r].length;c++)
            if(currentPiece.shape[r][c])
                board[currentPiece.y+r][currentPiece.x+c] = currentPiece.color;
    currentPiece=null;
    updateBlocksRemaining();
}

function rotate(){
    const s=currentPiece.shape;
    let rotated = s[0].map((_,i)=>s.map(row=>row[i]).reverse());
    if(!collision(currentPiece.x,currentPiece.y,rotated))
        currentPiece.shape=rotated;
}

function spawnPiece(){
    if(pieceIndex>=pieceOrder.length){
        updateBlocksRemaining();
        checkWin();
        return;
    }
    let p=PIECES[pieceOrder[pieceIndex]];
    pieceIndex++;

    currentPiece={
        shape:p.shape.map(r=>r.slice()),
        color:p.color,
        x:3, y:0
    };

    updateNextPreview();
    updateBlocksRemaining();
}

function updateNextPreview(){
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    if(pieceIndex>=pieceOrder.length) return;

    let p = PIECES[pieceOrder[pieceIndex]];
    let shape = p.shape;
    let color = p.color;

    const size=16;
    const rows=shape.length, cols=shape[0].length;
    let totalW=cols*size, totalH=rows*size;
    let ox=(nextCanvas.width-totalW)/2, oy=(nextCanvas.height-totalH)/2;
    nctx.fillStyle = COLORS[color];

    for(let r=0;r<rows;r++)
        for(let c=0;c<cols;c++)
            if(shape[r][c])
                nctx.fillRect(ox+c*size, oy+r*size, size-2, size-2);
}

function stepDown(){
    if(!currentPiece) return;
    if(!collision(currentPiece.x,currentPiece.y+1,currentPiece.shape)){
        currentPiece.y++;
    } else {
        placePiece();
        spawnPiece();
    }
}

function showMessage(msg, autoRestart){
    msgEl.innerHTML = msg;
    msgEl.style.display = "block";
    if(autoRestart){
        setTimeout(()=>{
            // LOSS auto-restart: DO NOT restart music, DO NOT reset targetRaised
            lossResetGame();
        },3000);
    }
}

function checkWin(){
    gameOver=true;
    // cutoff: blocks cannot be above top of target region
    const cutoff = targetRaised ? ROWS - 11 : ROWS - 10;
    let overflow=false;

    for(let r=0;r<cutoff;r++)
        for(let c=0;c<COLS;c++)
            if(board[r][c]) overflow=true;

    if(!overflow){
        lastResultWasWin=true;
        showMessage("You Win! Score: 286193", false);
        resetBarText.textContent = "Hold R to reset";

        // Play both win sounds at the same time
        if (winSound1) {
            try { winSound1.currentTime = 0; winSound1.play(); } catch(e) {}
        }
        if (winSound2) {
            try { winSound2.currentTime = 0; winSound2.play(); } catch(e) {}
        }
    } else {
        lastResultWasWin=false;
        showMessage("Try Again", true);
    }
}

// LOSS reset: DOES NOT restart music; DOES NOT reset targetRaised
function lossResetGame(){
    board = Array.from({length:ROWS},()=>Array(COLS).fill(0));
    pieceIndex=0;
    currentPiece=null;
    gameOver=false;
    lastResultWasWin=false;
    fallTimer=0;
    lastTime=0;
    softDrop=false;

    // reset timer & overlays for new attempt
    timerRemaining = TIMER_START_MS;
    aliensActive = false;
    escapeActive = false;
    updateTimerDisplay();
    alienOverlay.style.display = "none";
    escapeOverlay.style.display = "none";

    updateNextPreview();
    updateBlocksRemaining();
    // do NOT pause or restart music here
    gameStarted=true;
    msgEl.style.display="none";
    hideResetBar();
    hideRaiseBar();
    spawnPiece();
}

// FULL reset (holding R for 5s anytime) — restarts the music; targetRaised resets
function fullResetGame(){
    board = Array.from({length:ROWS},()=>Array(COLS).fill(0));
    pieceIndex=0;
    currentPiece=null;
    gameOver=false;
    lastResultWasWin=false;
    fallTimer=0;
    lastTime=0;
    softDrop=false;
    targetRaised = false;

    // reset timer & overlays
    timerRemaining = TIMER_START_MS;
    aliensActive = false;
    escapeActive = false;
    updateTimerDisplay();
    alienOverlay.style.display = "none";
    escapeOverlay.style.display = "none";

    updateNextPreview();
    updateBlocksRemaining();
    gameStarted=false;
    rHeld=false;
    rHoldStart=null;
    hideResetBar();
    hideRaiseBar();
    hHeld=false;
    hHoldStart=null;

    // STOP + REWIND MUSIC — only here
    bgm.pause();
    bgm.currentTime=0;

    // stop and rewind win sounds too
    if (winSound1) { winSound1.pause(); winSound1.currentTime = 0; }
    if (winSound2) { winSound2.pause(); winSound2.currentTime = 0; }

    msgEl.innerHTML = "Press any key to begin";
    msgEl.style.display = "block";
}

function startGame(){
    if(gameStarted) return;
    gameStarted=true;
    msgEl.style.display="none";

    // fresh timer state each run
    timerRemaining = TIMER_START_MS;
    aliensActive = false;
    escapeActive = false;
    updateTimerDisplay();
    alienOverlay.style.display = "none";
    escapeOverlay.style.display = "none";

    spawnPiece();
    // Music only starts once per full run
    try{ bgm.play(); }catch(e){}
}

// Reset bar helpers (R)
function showResetBar(){
    resetBarWrapper.style.display = "block";
}
function hideResetBar(){
    resetBarWrapper.style.display = "none";
    resetBarFill.style.width = "0%";
}
function updateResetBar(progress){
    showResetBar();
    const pct = Math.max(0, Math.min(1, progress)) * 100;
    resetBarFill.style.width = pct + "%";
}

// Raise bar helpers (H)
function showRaiseBar(){
    raiseBarWrapper.style.display = "block";
}
function hideRaiseBar(){
    raiseBarWrapper.style.display = "none";
    raiseBarFill.style.width = "0%";
}
function updateRaiseBar(progress){
    showRaiseBar();
    const pct = Math.max(0, Math.min(1, progress)) * 100;
    raiseBarFill.style.width = pct + "%";
}

// Input
document.addEventListener("keydown",(e)=>{
    if(e.key === "r" || e.key === "R"){
        rHeld = true;
    }
    if(e.key === "h" || e.key === "H"){
        hHeld = true;
    }
    if(e.key === "w" || e.key === "W"){
        wHeld = true;
    }

    // If game hasn't started yet (initial or after full reset), start when any arrow is pressed
    if(!gameStarted && ["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"].includes(e.key)){
        startGame();
        return;
    }

    // During win screen, ignore movement (but R still works via loop)
    if(gameOver && lastResultWasWin){
        return;
    }

    if(gameOver) return;
    if(!currentPiece) return;

    if(e.key==="ArrowLeft"&&!collision(currentPiece.x-1,currentPiece.y,currentPiece.shape))
        currentPiece.x--;
    if(e.key==="ArrowRight"&&!collision(currentPiece.x+1,currentPiece.y,currentPiece.shape))
        currentPiece.x++;
    if(e.key==="ArrowUp") rotate();
    if(e.key==="ArrowDown") softDrop=true;
});

document.addEventListener("keyup",(e)=>{
    if(e.key === "r" || e.key === "R"){
        rHeld = false;
        rHoldStart = null;
        hideResetBar();
    }
    if(e.key === "h" || e.key === "H"){
        hHeld = false;
        hHoldStart = null;
        hideRaiseBar();
    }
    if(e.key === "w" || e.key === "W"){
        wHeld = false;
        wHoldStart = null;
    }
    if(e.key==="ArrowDown") softDrop=false;
});

// main loop
function loop(t){
    if(!lastTime) lastTime=t;
    let dt=t-lastTime;
    lastTime=t;

    // timer logic: counts down while game running, stops at 0
    if(gameStarted && !escapeActive && !aliensActive && timerRemaining > 0){
        timerRemaining -= dt;
        if(timerRemaining <= 0){
            timerRemaining = 0;
            aliensActive = true;
            alienOverlay.style.display = "block";
        }
        updateTimerDisplay();
    }

    // W escape logic (5 second hold)
    if(!escapeActive && wHeld){
        if(wHoldStart === null) wHoldStart = t;
        let elapsed = t - wHoldStart;
        if(elapsed >= 5000){
            escapeActive = true;
            // stop timer & show black screen with text
            alienOverlay.style.display = "none";
            escapeOverlay.style.display = "block";
        }
    } else if(!wHeld){
        wHoldStart = null;
    }

    if(gameStarted && !gameOver){
        fallTimer+=dt;
        let interval = softDrop ? 60 : fallInterval;
        if(fallTimer>=interval){
            fallTimer=0;
            stepDown();
        }
    }
    drawBoard();

    // Reset logic with R key and progress bar (anytime)
    if(rHeld){
        if(rHoldStart===null) rHoldStart = t;
        let elapsed = t - rHoldStart;
        let progress = elapsed / 5000; // 5 seconds
        updateResetBar(progress);
        if(elapsed >= 5000){
            fullResetGame();
        }
    } else {
        rHoldStart = null;
        hideResetBar();
    }

    // Raise-target logic with H key during active game (only if not already raised)
    if(gameStarted && !gameOver && !targetRaised){
        if(hHeld){
            if(hHoldStart===null) hHoldStart = t;
            let elapsedH = t - hHoldStart;
            let progressH = elapsedH / 5000; // 5 seconds
            updateRaiseBar(progressH);
            if(elapsedH >= 5000){
                targetRaised = true;
                hideRaiseBar();
            }
        } else {
            hHoldStart = null;
            hideRaiseBar();
        }
    }

    requestAnimationFrame(loop);
}

// initial prompt
updateBlocksRemaining();
updateTimerDisplay();
msgEl.innerHTML="Press any key to begin";
msgEl.style.display="block";
requestAnimationFrame(loop);
</script>

</body>
</html>
