
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Tetris Fill with Music and Timer</title>
<style>
    body {
        background: #111;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        color: white;
        font-family: Arial, sans-serif;
    }
    #gameContainer { position: relative; }
    #board {
        background: #222;
        image-rendering: pixelated;
        border: 4px solid #555;
        display: block;
    }
    #message {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0,0,0,0.7);
        padding: 20px 40px;
        border-radius: 10px;
        font-size: 32px;
        text-align: center;
        display: none;
        pointer-events: none;
        z-index: 2;
    }
    #nextBox {
        position: absolute;
        top: 10px;
        right: -140px;
        width: 120px;
        height: 130px;
        border: 2px solid #666;
        background: #111;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        color: #bbb;
        font-size: 11px;
        padding: 4px;
        box-shadow: 0 0 10px rgba(0,0,0,0.6);
        z-index: 1;
    }
    #blocksRemaining {
        margin-top: 4px;
        font-size: 11px;
        color: #bbb;
        text-align: center;
    }
    /* Large timer on the left */
    #timer {
        position: absolute;
        left: -150px;
        top: 40px;
        font-size: 50px; /* option 2: medium-large */
        font-weight: bold;
        color: #fff;
    }
    audio { display:none; }

    /* Reset progress bar (R) */
    #resetBarWrapper {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 70%;
        max-width: 260px;
        display: none;
        text-align: center;
        font-size: 14px;
        z-index: 3;
    }
    #resetBarBG {
        width: 100%;
        height: 10px;
        background: rgba(255,255,255,0.2);
        border-radius: 5px;
        overflow: hidden;
        margin-bottom: 4px;
    }
    #resetBarFill {
        height: 100%;
        width: 0%;
        background: #4caf50;
        transition: width 0.1s linear;
    }

    /* Raise-target progress bar (H during game) */
    #raiseBarWrapper {
        position: absolute;
        bottom: 40px;
        left: 50%;
        transform: translateX(-50%);
        width: 70%;
        max-width: 260px;
        display: none;
        text-align: center;
        font-size: 14px;
        z-index: 3;
    }
    #raiseBarBG {
        width: 100%;
        height: 10px;
        background: rgba(255,255,255,0.2);
        border-radius: 5px;
        overflow: hidden;
        margin-bottom: 4px;
    }
    #raiseBarFill {
        height: 100%;
        width: 0%;
        background: #ff9800;
        transition: width 0.1s linear;
    }

    /* Fullscreen overlay for alien / escape */
    #fullOverlay {
        position: fixed;
        top: 0; left: 0;
        width: 100vw;
        height: 100vh;
        background: #000;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 999;
        color: #fff;
        text-align: center;
    }
    #fullOverlay img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
    #fullOverlayMessage {
        font-size: 48px;
        font-weight: bold;
    }

</style>
</head>
<body>

<div id="gameContainer">
    <canvas id="board"></canvas>
    <div id="message"></div>
    <div id="nextBox">
        <div id="nextLabel">Next</div>
        <canvas id="nextCanvas" width="80" height="60"></canvas>
        <div id="blocksRemaining">Blocks remaining: 23</div>
    </div>
    <div id="timer">60:00</div>

    <!-- Reset bar (R anytime) -->
    <div id="resetBarWrapper">
        <div id="resetBarBG">
            <div id="resetBarFill"></div>
        </div>
        <div id="resetBarText">Hold R to reset</div>
    </div>

    <!-- Raise-target bar (H during game) -->
    <div id="raiseBarWrapper">
        <div id="raiseBarBG">
            <div id="raiseBarFill"></div>
        </div>
        <div id="raiseBarText">Hold H to raise target</div>
    
    <!-- Escape bar (W held) -->
    <div id="escapeBarWrapper" style="display:none; position:absolute; bottom:70px; left:50%; transform:translateX(-50%); width:70%; max-width:260px; text-align:center; z-index:3; font-size:14px;">
        <div style="width:100%; height:10px; background:rgba(255,255,255,0.2); border-radius:5px; overflow:hidden; margin-bottom:4px;">
            <div id="escapeBarFill" style="height:100%; width:0%; background:#e91e63; transition:width 0.1s linear;"></div>
        </div>
        <div>Hold W to escape</div>
    </div>

    <!-- Pause bar (P held) -->
    <div id="pauseBarWrapper" style="display:none; position:absolute; bottom:95px; left:50%; transform:translateX(-50%); width:70%; max-width:260px; text-align:center; z-index:3; font-size:14px;">
        <div style="width:100%; height:10px; background:rgba(255,255,255,0.2); border-radius:5px; overflow:hidden; margin-bottom:4px;">
            <div id="pauseBarFill" style="height:100%; width:0%; background:#00bcd4; transition:width 0.1s linear;"></div>
        </div>
        <div>Hold P to pause/play timer</div>
    </div>
</div>
</div>

<!-- Fullscreen overlay (alien or escape message) -->
<div id="fullOverlay">
    <div id="fullOverlayContent"></div>
</div>

<!-- Background music: only restarts on FULL reset, not on Try Again -->
<audio id="bgm" src="mix-chunk-1_uLO4kfAU.mp3" loop></audio>
<audio id="escapeWinSound" src="orchestral-win-331233.mp3"></audio>

<!-- Win sounds: both play simultaneously on win -->
<audio id="winSound1" src="electric-motor-whir-77588.mp3"></audio>
<audio id="winSound2" src="win.mp3"></audio>
<audio id="alienSound" src="scary-scream-401725.mp3"></audio>

<script>
const COLS = 10, ROWS = 20, BLOCK = 30;
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");
const msgEl = document.getElementById("message");
const nextCanvas = document.getElementById("nextCanvas");
const nctx = nextCanvas.getContext("2d");
const bgm = document.getElementById("bgm");
const winSound1 = document.getElementById("winSound1");
const winSound2 = document.getElementById("winSound2");

const resetBarWrapper = document.getElementById("resetBarWrapper");
const resetBarFill = document.getElementById("resetBarFill");
const resetBarText = document.getElementById("resetBarText");

const raiseBarWrapper = document.getElementById("raiseBarWrapper");
const raiseBarFill = document.getElementById("raiseBarFill");

const blocksRemainingEl = document.getElementById("blocksRemaining");
const timerEl = document.getElementById("timer");

const fullOverlay = document.getElementById("fullOverlay");
const fullOverlayContent = document.getElementById("fullOverlayContent");

canvas.width = COLS * BLOCK;
canvas.height = ROWS * BLOCK;

let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
let pieceIndex = 0, currentPiece = null;
let gameOver = false, lastResultWasWin = false;
let gameStarted = false;

// smooth falling
let lastTime = 0, fallTimer = 0, softDrop = false;
const fallInterval = 650;

// R key hold for reset (now allowed anytime)
let rHeld = false;
let rHoldStart = null;

// H key hold for raising target zone
let hHeld = false;
let hHoldStart = null;
let targetRaised = false; // true when H has been held long enough this run

// P key hold for timer pause/play toggle
let pHeld = false;
let pHoldStart = null;

// W key hold for escape
let wHeld = false;
let wHoldStart = null;

// Timer state
const TIMER_START = 3600; // seconds
let timerRemaining = TIMER_START;
let timerRunning = false; // controlled via P and startGame
let timerFrozen = false;  // when alien or escape happens, no further changes

// Alien / escape states
let alienTriggered = false;
let escaped = false;

// COLORS
const COLORS = ["#000","#f44","#4f4","#44f","#ff4","#f4f","#4ff","#f80","#cc0"];

// PIECES
const PIECES = [
    {shape:[[1,1,1],[0,1,0]],color:1},
    {shape:[[2,2,0],[0,2,2]],color:2},
    {shape:[[0,3,3],[3,3,0]],color:3},
    {shape:[[4,4],[4,4]],color:4},
    {shape:[[8,8],[8,8]],color:8},
    {shape:[[6,6,6],[6,0,0]],color:6},
    {shape:[[7,7,7],[0,0,7]],color:7}
];

// hard-coded piece order (23 pieces)
let pieceOrder = [
    0,3,1,4,2,6,5,0,2,4,6,1,
    3,5,0,2,4,6,1,3,5,0,
    2
];

function updateBlocksRemaining(){
    if(!blocksRemainingEl) return;
    const total = pieceOrder.length;
    const used = pieceIndex;
    const current = currentPiece ? 1 : 0;
    const remaining = Math.max(0, total - used + current);
    blocksRemainingEl.textContent = "Blocks remaining: " + remaining;
}

function formatTime(secs){
    secs = Math.max(0, secs);
    const m = Math.floor(secs / 60);
    const s = Math.floor(secs % 60);
    return m + ":" + (s < 10 ? "0" + s : s);
}

function updateTimerDisplay(){
    timerEl.textContent = formatTime(timerRemaining);
}

function drawBlock(x,y,colorIndex){
    if(colorIndex===0) return;
    ctx.fillStyle = COLORS[colorIndex];
    ctx.fillRect(x*BLOCK, y*BLOCK, BLOCK-1, BLOCK-1);
}

function drawBoard(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    for(let r=0;r<ROWS;r++)
        for(let c=0;c<COLS;c++)
            drawBlock(c,r,board[r][c]);

    if(currentPiece){
        for(let r=0;r<currentPiece.shape.length;r++)
            for(let c=0;c<currentPiece.shape[r].length;c++)
                if(currentPiece.shape[r][c])
                    drawBlock(currentPiece.x+c, currentPiece.y+r, currentPiece.color);
    }

    // highlight target region
    // normal: bottom 10 rows; raised: top boundary moves up by 1, bottom row still included
    const startRow = targetRaised ? ROWS - 11 : ROWS - 10;
    const rowsHighlighted = ROWS - startRow; // 10 normally, 11 when raised
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.fillRect(0, startRow*BLOCK, COLS*BLOCK, rowsHighlighted*BLOCK);

    ctx.strokeStyle = "rgba(255,255,255,0.4)";
    ctx.lineWidth = 2;
    ctx.strokeRect(1, startRow*BLOCK+1, COLS*BLOCK-2, rowsHighlighted*BLOCK-2);
}

function collision(px,py,shape){
    for(let r=0;r<shape.length;r++){
        for(let c=0;c<shape[r].length;c++){
            if(shape[r][c]){
                let nx=px+c, ny=py+r;
                if(nx<0||nx>=COLS||ny>=ROWS) return true;
                if(ny>=0 && board[ny][nx]) return true;
            }
        }
    }
    return false;
}

function placePiece(){
    for(let r=0;r<currentPiece.shape.length;r++)
        for(let c=0;c<currentPiece.shape[r].length;c++)
            if(currentPiece.shape[r][c])
                board[currentPiece.y+r][currentPiece.x+c] = currentPiece.color;
    currentPiece=null;
    updateBlocksRemaining();
}

function rotate(){
    const s=currentPiece.shape;
    let rotated = s[0].map((_,i)=>s.map(row=>row[i]).reverse());
    if(!collision(currentPiece.x,currentPiece.y,rotated))
        currentPiece.shape=rotated;
}

function spawnPiece(){
    if(pieceIndex>=pieceOrder.length){
        updateBlocksRemaining();
        checkWin();
        return;
    }
    let p=PIECES[pieceOrder[pieceIndex]];
    pieceIndex++;

    currentPiece={
        shape:p.shape.map(r=>r.slice()),
        color:p.color,
        x:3, y:0
    };

    updateNextPreview();
    updateBlocksRemaining();
}

function updateNextPreview(){
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    if(pieceIndex>=pieceOrder.length) return;

    let p = PIECES[pieceOrder[pieceIndex]];
    let shape = p.shape;
    let color = p.color;

    const size=16;
    const rows=shape.length, cols=shape[0].length;
    let totalW=cols*size, totalH=rows*size;
    let ox=(nextCanvas.width-totalW)/2, oy=(nextCanvas.height-totalH)/2;
    nctx.fillStyle = COLORS[color];

    for(let r=0;r<rows;r++)
        for(let c=0;c<cols;c++)
            if(shape[r][c])
                nctx.fillRect(ox+c*size, oy+r*size, size-2, size-2);
}

function stepDown(){
    if(!currentPiece) return;
    if(!collision(currentPiece.x,currentPiece.y+1,currentPiece.shape)){
        currentPiece.y++;
    } else {
        placePiece();
        spawnPiece();
    }
}

function showMessage(msg, autoRestart){
    msgEl.innerHTML = msg;
    msgEl.style.display = "block";
    if(autoRestart){
        setTimeout(()=>{
            // LOSS auto-restart: DO NOT restart music, DO NOT reset targetRaised or timer
            lossResetGame();
        },3000);
    }
}

function checkWin(){
    gameOver=true;
    // cutoff: blocks cannot be above top of target region
    const cutoff = targetRaised ? ROWS - 11 : ROWS - 10;
    let overflow=false;

    for(let r=0;r<cutoff;r++)
        for(let c=0;c<COLS;c++)
            if(board[r][c]) overflow=true;

    if(!overflow){
        lastResultWasWin=true;
        showMessage("You Win! Score: 286193", false);
        resetBarText.textContent = "Hold R to reset";

        // Play both win sounds at the same time
        if (winSound1) {
            try { winSound1.currentTime = 0; winSound1.play(); } catch(e) {}
        }
        if (winSound2) {
            try { winSound2.currentTime = 0; winSound2.play(); } catch(e) {}
        }
    } else {
        lastResultWasWin=false;
        showMessage("Try Again", true);
    }
}

// LOSS reset: DOES NOT restart music; DOES NOT reset targetRaised or timer
function lossResetGame(){
    board = Array.from({length:ROWS},()=>Array(COLS).fill(0));
    pieceIndex=0;
    currentPiece=null;
    gameOver=false;
    lastResultWasWin=false;
    fallTimer=0;
    lastTime=0;
    softDrop=false;
    updateNextPreview();
    updateBlocksRemaining();
    // do NOT pause or restart music here
    gameStarted=true;
    msgEl.style.display="none";
    hideResetBar();
    hideRaiseBar();
    spawnPiece();
}

// FULL reset (holding R for 5s anytime) — restarts the music; targetRaised resets; timer resets
function fullResetGame(){
    board = Array.from({length:ROWS},()=>Array(COLS).fill(0));
    pieceIndex=0;
    currentPiece=null;
    gameOver=false;
    lastResultWasWin=false;
    fallTimer=0;
    lastTime=0;
    softDrop=false;
    targetRaised = false;
    alienTriggered = false;
    escaped = false;
    timerRemaining = TIMER_START;
    timerRunning = false;
    timerFrozen = false;
    updateNextPreview();
    updateBlocksRemaining();
    updateTimerDisplay();
    gameStarted=false;
    rHeld=false;
    rHoldStart=null;
    hideResetBar();
    hideRaiseBar();
    hHeld=false;
    hHoldStart=null;
    pHeld=false;
    pHoldStart=null;
    wHeld=false;
    wHoldStart=null;

    // STOP + REWIND MUSIC — only here
    bgm.pause();
    bgm.currentTime=0;

    // stop and rewind win sounds too
    if (winSound1) { winSound1.pause(); winSound1.currentTime = 0; }
    if (winSound2) { winSound2.pause(); winSound2.currentTime = 0; }

    // Hide overlay
    fullOverlay.style.display = "none";
    fullOverlayContent.innerHTML = "";

    msgEl.innerHTML = "Press any key to begin";
    msgEl.style.display = "block";
}

function startGame(){
    if(gameStarted) return;
    gameStarted=true;
    msgEl.style.display="none";
    spawnPiece();
    // Music only starts once per full run
    try{ bgm.play(); }catch(e){}
    // Start timer counting if not frozen
    if(!timerFrozen){
        timerRunning = true;
    }
}

// Reset bar helpers (R)
function showResetBar(){
    resetBarWrapper.style.display = "block";
}
function hideResetBar(){
    resetBarWrapper.style.display = "none";
    resetBarFill.style.width = "0%";
}
function updateResetBar(progress){
    showResetBar();
    const pct = Math.max(0, Math.min(1, progress)) * 100;
    resetBarFill.style.width = pct + "%";
}

// Raise bar helpers (H)
function showRaiseBar(){
    raiseBarWrapper.style.display = "block";
}
function hideRaiseBar(){
    raiseBarWrapper.style.display = "none";
    raiseBarFill.style.width = "0%";
}
function updateRaiseBar(progress){
    showRaiseBar();
    const pct = Math.max(0, Math.min(1, progress)) * 100;
    raiseBarFill.style.width = pct + "%";
}


// Escape (W) bar helpers
function showEscapeBar(){ document.getElementById("escapeBarWrapper").style.display = "block"; }
function hideEscapeBar(){ 
    document.getElementById("escapeBarWrapper").style.display = "none"; 
    document.getElementById("escapeBarFill").style.width = "0%"; 
}
function updateEscapeBar(p){ 
    showEscapeBar();
    document.getElementById("escapeBarFill").style.width = (Math.max(0, Math.min(1,p))*100) + "%";
}

// Pause (P) bar helpers
function showPauseBar(){ document.getElementById("pauseBarWrapper").style.display = "block"; }
function hidePauseBar(){ 
    document.getElementById("pauseBarWrapper").style.display = "none"; 
    document.getElementById("pauseBarFill").style.width = "0%"; 
}
function updatePauseBar(p){ 
    showPauseBar();
    document.getElementById("pauseBarFill").style.width = (Math.max(0, Math.min(1,p))*100) + "%";
}

// Input
document.addEventListener("keydown",(e)=>{
    if(e.key === "r" || e.key === "R"){
        rHeld = true;
    }
    if(e.key === "h" || e.key === "H"){
        hHeld = true;
    }
    if(e.key === "p" || e.key === "P"){
        pHeld = true;
    }
    if(e.key === "w" || e.key === "W"){
        wHeld = true;
    }

    // If overlay active (alien or escape), no game controls, only R via loop
    if(alienTriggered || escaped){
        return;
    }

    // If game hasn't started yet (initial or after full reset), start when any arrow is pressed
    if(!gameStarted && ["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"].includes(e.key)){
        startGame();
        return;
    }

    // During win screen, ignore movement (but R, P, H, W still processed via loop)
    if(gameOver && lastResultWasWin){
        return;
    }

    if(gameOver) return;
    if(!currentPiece) return;

    if(e.key==="ArrowLeft"&&!collision(currentPiece.x-1,currentPiece.y,currentPiece.shape))
        currentPiece.x--;
    if(e.key==="ArrowRight"&&!collision(currentPiece.x+1,currentPiece.y,currentPiece.shape))
        currentPiece.x++;
    if(e.key==="ArrowUp") rotate();
    if(e.key==="ArrowDown") softDrop=true;
});

document.addEventListener("keyup",(e)=>{
    if(e.key === "r" || e.key === "R"){
        rHeld = false;
        rHoldStart = null;
        hideResetBar();
    }
    if(e.key === "h" || e.key === "H"){
        hHeld = false;
        hHoldStart = null;
        hideRaiseBar();
    }
    if(e.key === "p" || e.key === "P"){
        pHeld = false;
        pHoldStart = null;
    }
    if(e.key === "w" || e.key === "W"){
        wHeld = false;
        wHoldStart = null;
    }
    if(e.key==="ArrowDown") softDrop=false;
});

function triggerAlienOverlay(){
    
    const alienSound = document.getElementById('alienSound');
    if(alienSound){ alienSound.currentTime=0; alienSound.play().catch(()=>{});} 
    alienTriggered = true;
    timerRunning = false;
    timerFrozen = true;
    fullOverlay.style.display = "flex";
    fullOverlayContent.innerHTML = '<div style="position:absolute;top:20px;left:20px;font-size:32px;color:white;z-index:2;">Time is up! The aliens have arrived!</div><img src="alien.png" alt="Alien">';
}

function triggerEscapeOverlay(){
    // Play the escape orchestral sound if present
    const esc = document.getElementById('escapeWinSound');
    if (esc) {
        esc.currentTime = 0;
        esc.play().catch(() => {});
    }

    // Mark game as escaped and freeze timer
    escaped = true;
    timerRunning = false;
    timerFrozen = true;

    // Compute elapsed time: 60 minutes (TIMER_START) - time remaining
    let elapsed = TIMER_START - timerRemaining;
    if (elapsed < 0) elapsed = 0;

    // Convert to MM:SS
    let mins = Math.floor(elapsed / 60);
    let secs = Math.floor(elapsed % 60);
    let timeStr = mins + ":" + (secs < 10 ? "0" + secs : secs);

    // Show full-screen escape message with final time
    fullOverlay.style.display = "flex";
    fullOverlayContent.innerHTML =
        '<div id="fullOverlayMessage">' +
        'Congratulations! You Escaped!<br>' +
        'Final Time: ' + timeStr +
        '</div>';
}

// main loop
function loop(t){
    if(!lastTime) lastTime=t;
    let dt=t-lastTime;
    lastTime=t;

    // Game & timer update only if no overlay
    if(!alienTriggered && !escaped){
        if(gameStarted && !gameOver){
            fallTimer+=dt;
            let interval = softDrop ? 60 : fallInterval;
            if(fallTimer>=interval){
                fallTimer=0;
                stepDown();
            }
        }

        // Timer countdown
        if(timerRunning && !timerFrozen && timerRemaining > 0){
            timerRemaining -= dt / 1000;
            if(timerRemaining <= 0){
                timerRemaining = 0;
                updateTimerDisplay();
                // Alien takeover when timer hits 0
                triggerAlienOverlay();
            } else {
                updateTimerDisplay();
            }
        }
    }

    drawBoard();

    // Reset logic with R key and progress bar (anytime)
    if(rHeld){
        if(rHoldStart===null) rHoldStart = t;
        let elapsed = t - rHoldStart;
        let progress = elapsed / 5000; // 5 seconds
        updateResetBar(progress);
        if(elapsed >= 5000){
            fullResetGame();
        }
    } else {
        rHoldStart = null;
        hideResetBar();
    }

    // Raise-target logic with H key during active game (only if not already raised)
    if(gameStarted && !gameOver && !targetRaised && !alienTriggered && !escaped){
        if(hHeld){
            if(hHoldStart===null) hHoldStart = t;
            let elapsedH = t - hHoldStart;
            let progressH = elapsedH / 5000; // 5 seconds
            updateRaiseBar(progressH);
            if(elapsedH >= 5000){
                targetRaised = true;
                hideRaiseBar();
            }
        } else {
            hHoldStart = null;
            hideRaiseBar();
        }
    }

    // P key: hold 5s to toggle pause/play timer (only if not frozen)
    if(!alienTriggered && !escaped && !timerFrozen && timerRemaining > 0){
        if(pHeld){
            if(pHoldStart === null) pHoldStart = t;
            let elapsedP = t - pHoldStart;
            if(elapsedP >= 5000){
                // toggle
                timerRunning = !timerRunning;
                pHoldStart = null; // require another 5s hold next time
            }
        } else {
            pHoldStart = null;
        }
    }

    // W key: hold 5s to escape before timer reaches 0
    if(!alienTriggered && !escaped && timerRemaining > 0){
        if(wHeld){
            if(wHoldStart === null) wHoldStart = t;
            let elapsedW = t - wHoldStart;
            if(elapsedW >= 5000){
                triggerEscapeOverlay();
                wHoldStart = null;
            }
        } else {
            wHoldStart = null;
        }
    }

    requestAnimationFrame(loop);
}

// initial prompt
updateBlocksRemaining();
updateTimerDisplay();
msgEl.innerHTML="Press any key to begin";
msgEl.style.display="block";
requestAnimationFrame(loop);
</script>

</body>
</html>
